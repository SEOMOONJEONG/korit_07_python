'''
4. collection들의 성격을 이용한 코딩 문제
        - collection들의 특징을 명확하게 이해하고 있는 상태에서 list , dictionary를 어쩌고~ 이용해서~ +a 문제로 나올겁니다.(응용)
'''

'''
Collection 응용 문제
문제: 쇼핑 목록 관리하기
사용자로부터 쇼핑 목록에 추가할 물건을 반복해서 입력받으세요. 사용자가 '끝'을 입력하면 입력을 멈춥니다. 
입력받은 물건들을 리스트에 저장한 뒤, 중복된 물건들을 제거하고 최종 쇼핑 목록을 출력하는 프로그램을 작성하세요.
        /중복된 물건들을 제거 → 리스트를 세트로 변환
실행 예:

쇼핑 목록에 추가할 물건을 입력하세요 ('끝'을 입력하면 종료): 사과
쇼핑 목록에 추가할 물건을 입력하세요 ('끝'을 입력하면 종료): 바나나
쇼핑 목록에 추가할 물건을 입력하세요 ('끝'을 입력하면 종료): 사과
쇼핑 목록에 추가할 물건을 입력하세요 ('끝'을 입력하면 종료): 오렌지
쇼핑 목록에 추가할 물건을 입력하세요 ('끝'을 입력하면 종료): 끝

최종 쇼핑 목록: ['사과', '바나나', '오렌지']
'''
# shopping_list = []
#
# while True:
#     item = input("쇼핑 목록에 추가할 물건을 입력하세요 (''끝을 입력하면 종료): ")
#     if item == '끝':
#         break
#     shopping_list.append(item)
#
# # 중복 제거를 위해 리스트를 세트로 변환
# unique_items_set = set(shopping_list)
# # unique_items_set > set을 내가 정의한거네? shoppint_list라는 리스트를 set으로 변환
# # 다시 리스트로 변환하여 출력
# final_shopping_list = list(unique_items_set)    # set은 순서가 없어서? 리스트로 다시 변환
#
# print(f"\n최종 쇼핑 목록: {final_shopping_list}")


'''
해설
이 문제는 리스트, 세트의 특성을 활용하여 중복을 제거하는 방법을 묻는 문제입니다. 세트(set)는 중복된 값을 저장할 수 없는 자료형이라는 특징을 이용합니다.


반복 입력 및 리스트 추가: while 반복문을 사용하여 사용자가 '끝'을 입력할 때까지 물건 이름을 shopping_list에 계속 추가합니다. 이 리스트는 중복된 값을 그대로 저장합니다.

unique_items_set = set(shopping_list): 이 부분이 핵심입니다. 리스트를 

set() 함수에 넣어주면, 파이썬은 자동으로 중복된 요소들을 제거하고 고유한 값만 남겨 새로운 세트를 만듭니다. 예를 들어, 


['사과', '바나나', '사과']는 {'사과', '바나나'}로 변환됩니다. 세트는 순서가 없으므로 출력 순서가 다를 수 있습니다.


final_shopping_list = list(unique_items_set): 마지막으로, 다시 list() 함수를 사용하여 순서가 있는 리스트로 변환합니다. 최종 결과는 중복이 제거된 깔끔한 쇼핑 목록이 됩니다. 이처럼 자료형 변환은 데이터를 다룰 때 매우 유용하고 강력한 도구입니다.
'''

'''
문제 2
문제: 학생 성적 관리 시스템
사용자로부터 학생 3명의 이름과 점수를 입력받아 딕셔너리에 저장하는 프로그램을 작성하세요. 점수는 정수로 입력받아야 합니다. 모든 학생의 정보 입력이 끝난 후, 전체 학생의 평균 점수를 계산하여 출력하세요.

실행 예:

1번째 학생의 이름을 입력하세요 >> 김민지
1번째 학생의 점수를 입력하세요 >> 95
2번째 학생의 이름을 입력하세요 >> 이서준
2번째 학생의 점수를 입력하세요 >> 88
3번째 학생의 이름을 입력하세요 >> 박지훈
3번째 학생의 점수를 입력하세요 >> 76

---
입력된 학생 정보: {'김민지': 95, '이서준': 88, '박지훈': 76}
전체 학생의 평균 점수는 86.33점 입니다.
'''
# students_scores = {}
#
# for i in range(3):
#     name = input(f"{i + 1}번째 학생의 이름을 입력하세요 >> ")
#     score = int(input(f"{i + 1}번째 학생의 점수를 입력하세요 >> "))
#     students_scores[name] = score
#
# # 점수만 추출하여 리스트로 변환
# scores_list = list(students_scores.values())
#
# # 평균 계산
# total_score = sum(scores_list)
# average_score = total_score / len(scores_list)
#
# print("---")
# print(f"입력된 학생 정보: {students_scores}")
# print(f"전체 학생의 평균 점수는 {average_score:.2f}점 입니다.")

'''
해설:
이 문제는 딕셔너리를 활용해 키-값 쌍으로 데이터를 저장하고, 저장된 **값(value)**을 추출해 계산에 활용하는 능력을 평가합니다.

딕셔너리 데이터 저장: for 반복문을 사용하여 사용자로부터 학생의 이름과 점수를 입력받고, students_scores[name] = score 방식을 통해 **이름을 키(key)**로, **점수를 값(value)**으로 딕셔너리에 저장합니다. 딕셔너리는 키를 통해 값을 쉽게 찾을 수 있는 구조입니다. 


값(value) 추출: students_scores.values() 메서드를 사용하면 딕셔너리에 저장된 모든 값들을 dict_values 객체 형태로 얻을 수 있습니다. 이 객체를 

list() 함수로 변환하여 점수들만 모인 리스트를 만듭니다. 

평균 계산: sum() 함수로 점수 리스트의 총합을 구하고, len() 함수로 학생 수를 구한 뒤, 총합을 학생 수로 나누어 평균을 계산합니다. 마지막으로, f-string의 :.2f를 사용해 소수점 둘째 자리까지 출력합니다.

이 문제는 단순한 데이터 입력뿐만 아니라, 

딕셔너리의 특정 요소(값)만 추출하여 연산에 활용하는 방식을 보여주는 좋은 예시입니다. 
'''

'''
최종문제
문제 3 : 장바구니 + 가격 관리 시스템

사용자로부터 장바구니에 담을 물건과 가격을 입력받으세요.

사용자가 '끝'을 입력하면 입력을 멈춥니다.

입력받은 물건은 딕셔너리에 {물건명: 가격} 형태로 저장합니다.

만약 같은 물건이 여러 번 입력되면, 중복은 제거하고 마지막으로 입력한 가격을 기준으로 저장합니다.

최종적으로 모든 물건 목록과 평균 가격을 출력하세요.



물건 이름을 입력하세요 ('끝'을 입력하면 종료): 사과
사과의 가격을 입력하세요 >> 1000
물건 이름을 입력하세요 ('끝'을 입력하면 종료): 바나나
바나나의 가격을 입력하세요 >> 2000
물건 이름을 입력하세요 ('끝'을 입력하면 종료): 사과
사과의 가격을 입력하세요 >> 1200
물건 이름을 입력하세요 ('끝'을 입력하면 종료): 오렌지
오렌지의 가격을 입력하세요 >> 1500
물건 이름을 입력하세요 ('끝'을 입력하면 종료): 끝

---
최종 장바구니: {'사과': 1200, '바나나': 2000, '오렌지': 1500}
평균 가격: 1566.67원
'''
shopping_dict = {}

while True:
    item = input("물건 이름을 입력하세요 ('끝'을 입력하면 종료): ")
    if item == "끝":
        break
    price = int(input(f"{item}의 가격을 입력하세요 >> "))
    shopping_dict[item] = price   # 같은 물건 입력 시, 마지막 가격으로 갱신됨
    # dict 안에 key값을 넣을거기때문에 [] 대괄호. item 이 key 고 price 가 value
    # 이름 같으면 item == item 필요없음. 왜? 자동으로 갱신된다는 뉘앙스...ㅇㅇ...

print("\n---")
print(f"최종 장바구니: {shopping_dict}")

# 가격만 뽑아서 평균 계산
prices = list(shopping_dict.values())   # 어쨋든 이게 가격만 뽑아서 list에 변환 후 저장한거.
# 방법1
print(shopping_dict.values())     # dict.value()는 계산 할 수 없으니까  list로 변환
total = 0
for p in prices:
    total += p

if len(prices) > 0:
    average_price = total / len(prices)
    print(f"평균 가격: {average_price:.2f}원")
else:
    print("장바구니가 비어 있어 평균을 계산할 수 없습니다.")

# 방법2
# total = 0
# count = 0
#
# for _, price in shopping_dict.items():
#     total += price
#     count += 1
#
# if count > 0:
#     average_price = total / count
#     print(f"평균 가격: {average_price:.2f}원")
# else:
#     print("장바구니가 비어 있어 평균을 계산할 수 없습니다.")

'''
해설

딕셔너리 사용 (shopping_dict)
키(key): 물건 이름
값(value): 가격

동일한 물건을 다시 입력하면 같은 key가 갱신되므로 중복 자동 제거 효과가 생김.
중복 처리 로직

리스트 + set으로 중복 제거할 필요가 없음.
dict는 같은 키 중복 불허 특징을 이용해서 마지막 가격만 저장.
값만 추출 후 계산

shopping_dict.values() → 가격들만 모음.
sum() / len()으로 평균 계산.
'''