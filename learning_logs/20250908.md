```python
class Student:
    def __init__(self, name, student_id):
        self._name: name
        self._student_id = student_id
        # 성적을 저장하기 위한 빈 딕셔너리 → 과목명이 key, 점수가 value가 되겠네요.
        self._grades = {}
```

1. 지난 복습 시간에 Java version의 setter / getter를 생성했습니다.
   - 그런데 Java에는 access modifier 개념이 있었기 때문에 field를 private으로 선언했다면 setter / getter는 그냥 필수적이라고 봐도 됩니다.
   - 문제는 python에는 access modifier라고 할만한 개념이 없기 때문에 모든 객체의 속성이 외부로 노출됩니다.
2. 이상을 이유로 python에서는 `_속성명` 이라고 명시하게 되면, '내부적으로만 사용하라고 권장되는 변수' 라고 개발자들끼리 약속한 개념에 가깝습니다.
3. name vs. _name
   - name
     - 공개적으로 접근 가능한 속성(Public Attribute)
     - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며, 다른 개발자가 이 변수를 직접 사용해도 괜찮음
     - `예시 : student.name = '김일'` 과 같이 직접 언급하여 사용
   - _name
     - 내부용, 또는 비공개 속성(Private Attribute)
     - python에는 Java와 같은 엄격한 접근 제어자가 없기 때문에 _를 붙여서 '외부에서 접근하지 마세요'와 같은 의미만 전달.
     - 이런 변수는 일반적으로 `@property` 데코레이터를 사용한 getter와 setter를 경유하여 간접적으로 접근하는 것이 올바른 방법.
   
07_classes > student > main

```python
class Student:
    # 생성자 정의
    def __init__(self, name, student_id):
        self._name = name
        self._student_id = student_id
        # 성적을 저장하기 위한 빈 딕셔너리 → 과목명이 key, 점수가 value가 되겠네요.
        self._grades = {}

    #python 버전의 getter에 해당함
    @property
    def name(self):
        return self._name

    # python 버전의 setter 예시
    @name.setter        # 속성명.setter
    def name(self, value):
        self._name = value

student1 = Student('김일', 2025001)
# getter의 호출 예시 객체명.속성명 → 객체명.메서드명()이 아니라는 것에 주목해야 합니다.
print(f'학생 이름 : {student1.name}')   # 필드와 메서드 구분 ? '()소괄호' 여부

# setter의 호출 예시
student1.name = '김영'
# getter 재호출
print(f'변경된 학생 이름 : {student1.name}')
```
이상의 코드에서 확인 가능한 것은 Java를 기준으로만 python 코드를 생각할 때 의문스러운 점이 많다는 겁니다.
1. _name이라는 속성이 있는데 객체명.name을 통해서 '김일' / '김영'이라는 속성값이 출력된다는 점.
2. 객체명._name = '김영'이 아니라 객체명.name = '김영'으로 객체의 속성값을 직접 바꾼것처럼 보인다는 점.

이 문제가 되겠습니다.

그런데 이건 Java 기준으로 본 것이고 python으로 풀었을 때는,
애초에 _name / name은 서로 다른 개념인데 '_'가 붙으면 파이썬 언어 내부적으로 동일한 속성으로 처리해줍니다.

다만 더 신기한 것은 객체명.속성명 뒤에 ()가 없음에도 불구하고 그냥 파이썬은 이걸 메서드처럼 처리해준다는 겁니다.
그래서 '객체명.속성명'이면 getter로 처리해주고,
'객체명.속성명 = 데이터'면 setter로 처리해준다고 보시면 됩니다.

이상의 코드라인이 성립하기 위해서 필수적인 부분이
'@property'와 '@속성명.setter'라는 '데코레이터(decorator)'때문입니다.

# JPA 에서의 객체 생성 vs. python에서의 객체 생성
JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제합니다(Springboot 에서도 적용됩니다.) 그런데 python에서는 매개변수 생성자를 '권장'하는데, 이는 두 언어 간의 객체지향 패러다임과 데이터 관리 방식의 차이에 기인합니다.

1. Java(JPA)에서의 기본 생성자
   - JPA는 DB의 테이블과 (엔티티)클래스를 매핑하여 객체를 관리합니다.(추후 수업 할 거지만 제가 이미 이야기 한대로라면 엔티티 클래스의 field가 DB에서의 컬럼명이 된다고 했었습니다.) 이 과정에서 JPA가 직접 매개변수를 알 수 는 없기 때문에 매개변수가 없는 기본 생성자를 먼저 호출하여 객체를 생성하고, DB에서의 컬럼값들을 하나 씩 필드에 집어 넣어 줍니다. 이상을 이유로 JPA는 데이터 관리의 일관성과 효율성을 위해 기본 생성자를 강제합니다.
```java
@Entity
@Data
public class Student {
    private String name;
    private int studentCode;
    
    // 기본 생성자가 강제됨
    public Student(){}
}

public class StudentMain {
    main{
        Student student1 = new Student();
        student1.setName('김일');
        student1.setStudentCode(2025001);
    }
}
```
이상의 코드라인처럼 일단 필드에 아무런 값이 없는 객체를 생성한 후에, DB 상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해서 집어넣어 주는 과정을 거치기때문에 생성자를 강제합니다.

2. python에서의 매개변수 생성자
   - 파이썬은 Java와 달리 동적 타이핑(Dynamic Typing) 언어라고 해서, 객체를 생성할 때 필수 속성들을 한 번에 초기화 하는것을 권장합니다.
     1. 객체 무결성 보장 : init 메서드(생성자겠네요)에서 모든 필수 매개변수를 받으면, 객체가 생성되는 시점에 이미 완전한 상태를 갖게 됩니다.
     2. 명확한 코드 작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지를 명확하게 알 수 있습니다. Java처럼 순서대로 하는 것도 아니고 keyword argument를 지원하기도 하니까요.

그리고 python과 DB의 연동에 있어서 JPA처럼 값을 하나씩 집어넣기 보다는 ORM(Object-Relational Mapping) 라이브러리를 통해서 객체를 생성할 때 필요한 데이터를 직접 전달하는 방식으로 JPA와의 차이점이 있어 기본 생성자를 강제할 필요가 없습니다.

* 요약 : JPA는 DB와 연동하기 위한 기술적 제약으로 인해 기본 생성자를 명시해야 하는 귀찮은 점이 있는데(매개변수 생성자를 하나라도 정의하는 순간 기본 생성자도 정의해야 하니까요. 그게 귀찮으면 롬복에서 @NoArgsConstructor를 쓰겠지), python은 객체의 완전성과 가독성을 중시하는 언어적 특성상 매개변수 생성자를 더 권장합니다.


ch08_coffee_machine / pop_version / oop_version


### pop_coffee_machine 연습
MENU = {
    '에스프레소' : {
        '재료': {
            '물': 50,
            '커피': 18,
        },
        '가격': 1.5,
    },
    '라떼': {
        '재료': {
            '물': 200,
            '우유': 150,
            '커피': 24,
        },
        '가격': 2.5,
    },
    '카푸치노': {
        '재료': {
            '물': 250,
            '우유': 100,
            '커피': 24,
        },
        '가격': 3.0,
    },
}

# 실행 예
# 카푸치노에는 우유가 100ml가 들어갑니다.
# 라고 콘솔에 출력할 수 있도록 카푸치노의 우유량을 추출하는 코드를 작성하시오.
# print(f'카푸치노에는 {MENU['카푸치노']['재료']['우유']}ml가 들어갑니다.')   # 결과값 : 카푸치노에는 100ml가 들어갑니다.
#
# # 에스프레소의 가격을 추출하시오.
# print(f'에스프레소의 가격 : {MENU['에스프레소']['가격']}') # 결과값 : 에스프레소의 가격 : 1.5
# # 라떼의 재료를 재료 이름만 출력하시오.
# print(f'라떼의 재료 이름 : {MENU['라떼']['재료'].keys()}') # 결과값 : 라떼의 재료 이름 : dict_keys(['물', '우유', '커피'])
#
# print('# 1')
# for key in MENU['라떼']['재료']:        # dictionary에서 반복문을 돌리게 되면 key가 나온다. 그리고 그 key를 이용해서 value 조회 가능
#     print(key, end=' ')                 # 결과값 : 물 우유 커피
# print()
#
# print('# 2')
# print(' '.join(MENU['라떼']['재료'].keys()))            # 결과값 : 물 우유 커피
#

'''
38번 라인의 코드 작성 방식의 경우 key를 추출하여 dictionary의 value값에 접근할 수 있습니다. 그렇다면 연산이 가능하다는 의미도 됩니다.

43번 라인의 코드 작성 방식의 경우 value를 추출하는 것이 불가능하지만 한 줄에 간단하게 쓸 수 있다는 장점이 있습니다.(method를 아는 사람들에게만요)

에스프레소 / 라떼 / 카푸치노를 50잔씩 만든다고 가정했을 때 필요한
커피 / 우유 / 물의 양은 얼마인가?
'''
print(f'50잔씩 만든다고 가정했을 때 필요한 재료들의 양')
# print(MENU['에스프레소']['재료'].values())
# 결과값 : dict_values([50, 18])   / 물, 커피
# print(MENU['라떼']['재료'].values())
# 결과값 : dict_values([200, 150, 24]) / 물, 우유, 커피
# print(MENU['카푸치노']['재료'].values())
# 결과값 : dict_values([250, 100, 24]) / 물, 우유, 커피
coffee = 0
water = 0
milk = 0
for key in MENU:    # 결과값 : 에스프레소 / 라떼 / 카푸치노
    # print(MENU[key]['재료'])
    for key_key in MENU[key]['재료']:
        # print(f'{key} : {key_key}')
        '''
        결과값 : 
        {'물': 50, '커피': 18}
        에스프레소 : 물
        에스프레소 : 커피
        {'물': 200, '우유': 150, '커피': 24}
        라떼 : 물
        라떼 : 우유
        라떼 : 커피
        {'물': 250, '우유': 100, '커피': 24}
        카푸치노 : 물
        카푸치노 : 우유
        카푸치노 : 커피
        '''
        # print(MENU[key]['재료'][key_key])
        '''
        {'물': 50, '커피': 18}
        50
        18
        {'물': 200, '우유': 150, '커피': 24}
        200
        150
        24
        {'물': 250, '우유': 100, '커피': 24}
        250
        100
        24
        '''
        if key_key == '커피':
            coffee += MENU[key]['재료'][key_key]
        elif key_key == '물':
            water += MENU[key]['재료'][key_key]
        elif key_key == '우유':
            milk += MENU[key]['재료'][key_key]

print(f'커피 : {coffee * 50}')
print(f'물 : {milk * 50}')
print(f'우유 : {water * 50}')

'''
이상의 학습 과정에서 중요한 부분은 중첩적으로 이루어진 dictionary - JSON - 기타 collections들이 합쳐진 데이터에서 내가 필요한 부분을 어떻게 추출할 수 있을까 입니다.

일반적으로는 list의 경우 index를 이용하기 때문에 반복문 쓰고 치우면 그만인데 반해 dictionary는 반복문을 돌리면 key가 나오게 되고, 그 key를 또 이용해야지만 value가 추출됩니다.

그리고 그 value를 이용해서 연산을 하거나 로직을 작성해야 하죠.

근데 value가 또 dictionary거나 list거나 혹은 객체거나 한 경우에는 좀 복잡해집니다.
이를 연습하기 위한 수업이었고, coffee_machin을 작성하면서는 중첩 dictionary를 활용하도록 하겠습니다.
'''