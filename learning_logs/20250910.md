from idlelib.help import copy_strip

# 공지사항
1. 조퇴절차
   - 조퇴 절차
     1. 멘토 / 국비담당자님한테 메시지 보내서 허가 떨어진다.
     2. 그걸 강사한테 보여준다.
     3. 그러면 조퇴

```python
MENU = {
    '에스프레소' : {
        '재료': {
            '물': 50,
            '커피': 18,
        },
        '가격': 1.5,
    },
    '라떼': {
        '재료': {
            '물': 200,
            '우유': 150,
            '커피': 24,
        },
        '가격': 2.5,
    },
    '카푸치노': {
        '재료': {
            '물': 250,
            '우유': 100,
            '커피': 24,
        },
        '가격': 3.0,
    },
}

profit = 0
resources = {
    '물': 300,
    '우유': 200,
    '커피': 100,
}

'''
현재 자판기 내에 있는 물 / 우유 / 커피 / 금액 에서 라떼 한잔을 뽑고나서의 물 / 우유 / 커피 / 금액의 변동을 콘솔에 출력하시오.

실행 예
물 : xml
우유 : xml
커피 : xg
수익 : $x
'''
# profit += MENU['라떼']['가격']
# print(f'수익 : ${profit}')

# # 방법 1. 하드코딩(별로 추천하지 않음_feat:노가다버전)
# resources['물'] -= MENU['라떼']['재료']['물']
# print(f'물 : {resources['물']}ml')

# 방법 2. 반복문 version
for key in resources:   # dict 반복문 돌릴 때 안 헷갈리게 변수명을 그냥 key로 지정, list / tuple일 경우 i 를 사용
    resources[key] -= MENU['라떼']['재료'][key]
    # print(resources[key])
    if key == '커피':
        print(f'{key} : {resources[key]}g')
    else :
        print(f'{key} : {resources[key]}ml')
```
20250908에서는 dictionary 내부의 value들을 조회하는 정도에 그쳤지만 금일 수업에서는 필요한 value들을 다양한 방법을(key를 일일이 지정해서 넘어가거나 / 반복문을 작성하거나)통해 추출한 후에 이를 연산하는 것 까지 처리하고 있습니다.
이상의 코드는 그 예시이고, 앞으로의 데이터를 다루는 부분에 있어서 매우 중요합니다. <br>
SQL 에서도 각각 칼럼에 있는 값들을 필요한 것들을 추출해서 연산한 후에 집계함수를 사용하는 등의 응용이 있을 수 있으니 python으로 작성하는 법 뿐만 아니라 원리 자체를 학습하시면 더 좋습니다.

# coffee_machine_oop_version 관련 수업
```python
class MenuItem:
    """각 메뉴 아이템들을 모델링합니다."""
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }


class Menu:
    """음료 메뉴를 모델링합니다."""
    def __init__(self):
        self.menu = [
            MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5),
            MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
            MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
            # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
        ]

    def get_items(self):
        """이용 가능한 모든 메뉴 아이템의 이름을 반환합니다."""
        options = ""
        for item in self.menu:
            options += f"{item.name}/"
        return options

    def find_drink(self, order_name):
        """특정 음료를 이름으로 메뉴에서 검색합니다. 해당 아이템이 존재하면 반환하고, 그렇지 않으면 None을 반환합니다."""
        for item in self.menu:
            if item.name == order_name:
                return item
        print("죄송합니다. 해당 아이템은 이용할 수 없습니다.")
```
이상의 코드에서 저희가 python 상에서 잘 보지 못했던 부분들을 검증합니다.
```python
class MenuItem:
    """각 메뉴 아이템들을 모델링합니다."""
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }
```
class MenuItem의 경우 객체를 생성할 때, 이름, 물, 우유, 커피, 가격을 매개변수로 받습니다. 그런데 여태까지의 경우
```python
class MenuItem:
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.water = water
        self.milk = milk
        self.coffee = coffee
        self.cost = cost
```
의 형태로 썼던 것과 달리 water / milk / coffee 매개변수들은 전부 ingredient라는 매개변수에 속하지 않은 속성(인스턴스 변수)의 dictionary value값으로 지정되어 있다는 점입니다. 앞으로 저희가 Java / Springboot / Python 상에서 객체의 field / instance variable들이 매개변수 생성자의 argument들과 반드시 일치하지 않는 경우도 나오게 될 겁니다.

```python
class Menu:
    """음료 메뉴를 모델링합니다."""
    def __init__(self):
        self.menu = [
            MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5),
            MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
            MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
            # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
        ]
```
이상의 코드에서 Menu 객체를 생성한다고 가정하겠습니다.
```python
menu = Menu()
```
라고 생성해야 합니다. 이유는 139 번 라인 확인하시면 됩니다. ( # def__init__(self) 다음 아무것도 없기 때문에 Menu()로 가능 )
그렇다면 menu 라고 하는 객체를 생성했을 때, menu.menu 라는 인스턴스 변수가 있다는 것을 확인할 수 있습니다.
그리고 그 인스턴스 변수의 자료형은 list가 될 것이고, 내부 element의 자료형은 MenuItem의 객체라고 볼 수 있겠네요. <br>
또한 MenuItem 객체를 생성할 때 반드시 name / water / milk / coffee / cost를 요구했기 때문에 `MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5)`와 같은 방식으로 작성되었습니다. <br> 즉 menuItem=(name="latte", water=200, milk=150, coffee=24, cost=2.5) <br>
이라고 생각한다면 여러분들이 좀 더 이해하기 쉽습니다.

매개변수 생성자를 호출하여 name / water / milk / coffee / cost를 keyword argument를 통해서 값을 집어넣었고, 이를 menu.menu의 0번지, 1번지, 2번지에 넣는 방식으로 이루어졌다고 하면
```java
public class Main {
    main {
    
        Student[] students = new Student(new MiddleSchool(), new HighSchool())
    }
} 
```
처럼 저희가 Java에서 객체 생성할 때 내부 element로 new 생성자(); 형태로 객체의 이름이 없는 객체들을 만들어서 collections의 element로 써먹은 적이 있습니다.

동일한 예시라고 보시면 되겠습니다.

```python
def process_coins() :
    """ 동전들을 입력받아 전체 금액을 반환하는 함수 call3()유형 """
    sum = 0
    sum += float(input('쿼터 동전을 몇개나 넣으시겠습니까? >>> ')) * 0.25
    sum += float(input('다임 동전을 몇개나 넣으시겠습니까? >>> ')) * 0.1
    sum += float(input('니켈 동전을 몇개나 넣으시겠습니까? >>> ')) * 0.05
    sum += float(input('페니 동전을 몇개나 넣으시겠습니까? >>> ')) * 0.01
    return sum

def is_transaction_successful(money_received, drink_cost) :
    """ proess_coins()의 결과값과 음료 가격을 매개변수로 받아 받은 동전의 총합이 음료 가격보다 높으면 True / 아니면 False 반환. 그리고 True인 경우에는 profit에 음료 가격만큼 추가해야하고 False인 경우에는 받은 동전들을 반환해주는 안내문 출력 """
    change = money_received - drink_cost
    if change >= 0 :
        global profit
        profit += drink_cost
        print(f'잔돈 ${change}을(를) 반환합니다.')
        return True
    else :
        print(f'금액이 충분하지 않습니다. ${money_received}를 반홥합니다.')
        return False

 def process_coins(self):
        """투입된 동전으로부터 계산된 총액을 반환합니다."""
        print("동전을 투입해주세요.")
        for coin in self.COIN_VALUES:
            self.money_received += int(input(f"{coin}는 몇 개입니까?: ")) * self.COIN_VALUES[coin]
        return self.money_received

    def make_payment(self, cost):
        """지불이 성공했을 때 True를 반환하고, 돈이 부족하면 False를 반환합니다."""
        self.process_coins()
        if self.money_received >= cost:
            change = round(self.money_received - cost, 2)   # 반올림
            print(f"여기 잔돈 {self.CURRENCY}{change}를 반환합니다.")
            self.profit += cost
            self.money_received = 0
            return True
        else:
            print("죄송합니다. 돈이 충분하지 않습니다. 돈을 반환합니다.")
            self.money_received = 0
            return False
```
이상의 코드는 pop version의 process_coins() / is_transaction_successful()과
oop version의 process_coins() / make_payment()입니다.

주목해야 할 점은 make_payment() 내부에서 process_coins()를 호출한다는 점입니다.
그 의미는 pop version의 main에서는 process_coins()를 호출하여 moeney_received에 저장할 필요가 있었지만, oop version에서는 make_payment()만 호출하면 알아서 process_coins()의 결과값을 가지고 온다는 점입니다.

그 결과로 is_transaction_successful()를 정의할 때에는 두 개의 매개변수가 필요했었습니다.(money_received, drink_cost).

하지만 make_payment()의 경우에는 내부에서 process_coins()를 호출하기 때문에 하나의 매개변수만 있으면 됩니다.(cost)
```python
'''
1. 클래스 변수 vs. 인스턴스 변수
    인슨턴스 변수 : 인스턴스 마다 서로 다른 값을 가지는 변수
    클래스 변수 : 모든 인스턴스가 동일한 값을 지니는 변수(Java에서는 정적 변수)

    인스턴스 변수
        목적 - 인스턴스마다 서로 다른 값을 저장
        접근 방식 - 인스턴스 접근(o)
                - 클래스 접근(x)

    클래스 변수 :
        목적 - 인스턴스가 공유하는 값을 저장
        접근 방식 - 인스턴스 접근(o)
                - 클래스 접근(o)
'''
# # 클래스 변수 예시
# class Korean:
#     country = '한국'                # 클래스 변수 # 1
#     # 인스턴스 변수의 경우는 생성자 내부에 있었습니다(__init__내부).
#     # 클래스 변수는 이상처럼 클래스 내부에 선언하고 초기화하면 됩니다.
#
#     def __init__(self, name, age, address):
#         self.name = name            # 인스턴스 변수 # 1
#         self.age = age              # 인스턴스 변수 # 2
#         self.address = address      # 인스턴스 변수 # 3
#
# # 객체 생성
# man1 = Korean('김일', 21, '서울특별시 종로구')
# print(man1.name)            # 인스턴스 변수 참조
# print(man1.age)
# print(man1.address)
#
# print(man1.country)         # 결과값 : 한국
# print(Korean.country)       # 결과값 : 한국
'''
객체명.클래스변수 를 통해서 클래스 변수에 접근이 가능하긴하지만, 클래스 내부의 코드를 들여다보기 전까지는 country라는 변수가 인스턴스 변수인지 클래스 변수인지 알 방법이 없다는 문제가 있습니다.

이상을 이유로 클래스 변수를 확인하고자 할 때는 객체명.클래스변수명 보다는
클래스명.클래스변수명 을 통해서 참조하는 것이 권장됩니다.

2. 클래스 메서드 : 클래스 변수를 사용하는 메서드
'''
# class Korean2:
#     country = '대한민국'    # 클래스 변수의 선언 및 초기화
#
#     # 클래스 메서드 정의 방법
#     @classmethod                        # @Classmethod 데코레이터를 달면 클래스 메서드로 인지함.
#     def trip(cls, travelling_site):     # 그 결과 첫 번째 매개변수가 self가 아니라 cls
#         if cls.country == travelling_site:
#             print('국내 여행 입니다. 🚄')
#         else:
#             print('해외 여행 입니다. ✈️')
# # 클래스 메서드의 호출
# Korean2.trip('대한민국')    # 결과값 : 국내 여행 입니다. 🚄
# Korean2.trip('미국')      # 결과값 : 해외 여행 입니다. ✈️
# man2 = Korean2()
# man2.trip('일본')         # 결과값 : 해외 여행 입니다. ✈️
# # 클래스 변수와 마찬가지로 객체명.클래스메서드명() 으로 호출이 가능하기는 하지만 마찬가지로 이게 인스턴스 메서드인지 알 바가 아니기 때문에 클래스메서드를 호출할 때는
# # 클래스명.클래스메서드명()으로 하는것이 권장됩니다.
'''
    특징 : 
        1) 인스턴스 / 클래스로 호출 가능 → 하지만 클래스로 호출하도록 권장
        2) 생성된 인스턴스가 없어도 호출 가능(클래스로 호출하면 되니까)
        3) @classmethod 데코레이터(decorator)를 표시하고 작성
        4) 매개변수 cls를 사용 → self는 객체를 의미하고 / cls는 클래스를 의미합니다.
        
3. 정적 메서드(static method)
    : 정적 메서드 또한 self를 사용하지 않음 → 즉, 인스턴스 변수에 접근하여 사용하는 것이 불가능함을 의미. self.속성명 을 사용하여 인스턴스 변수의 값을 참조하는데 정적 메서드는 아예 첫 번째 매개변수가 고정이 아닙니다. → 클래스 메서드와의 공통점 # 1
    
    인스턴스를 생성하지 않아도 사용할 수 있음 → 클래스 메서드와의 공통점 # 2
    
    특징 : 
        1) 인스턴스 / 클래스로 호출 가능 → 클래스 메서드와의 공통점
        2) 생성된 인스턴스가 없어도 호출 가능 → 클래스 메서드와의 공통점
        
        3) @staticmethod 데코레이터를 표기하고 작성 → 클래스 메서드와의 차이점 # 1
        4) 반드시 작성해야 할 매개변수(self / cls)가 없음 → 클래스 메서드와의 차이점 # 2

이상을 토대로, 정적 메서드는 self / cls를 둘 다 사용하지 않기 때문에 인스턴스 / 클래스 변수를 모두 사용하지 않는 메서드를 정의하는 경우에 적합 합니다. 정적 메서드 자체는 클래스에 소속돼있지만 인스턴스에는 영향을 주지도 않고 받지도 않습니다.

즉 Java에서의 정적 메서드 = 파이썬의 클래스 메서드 + 정적 메서드
'''
# class Korean3:
#     country = '한국'      # 클래스 변수
#
#     @staticmethod
#     def slogan():
#         print('Imagine Your Korea ! ✌️')
#
#     @staticmethod
#     def slogan2(str_example):
#         '''얘는 그냥 매개변수가 있는 앱니다.'''
#         print('Imagine Your Korea ! ✌️' + str_example)
#
# Korean3.slogan()                        # 결과값 : Imagine Your Korea ! ✌️
# Korean3.slogan2(' 근데 너무 덥다.')       # 결과값 : Imagine Your Korea ! ✌️ 근데 너무 덥다.
'''
기본 예제

가방을 만들 때마다 현재 만들어진 가방이 몇 개인지 계산할 수 있는 Bag 클래스를 정의할겁니다.
'''
# # 클래스 정의
# class Bag:
#     # 클래스 변수의 선언 및 초기화
#     count = 0
#
#     def __init__(self): # 생성자 호출 및 인스턴스 변수를 정의할 용도. 그럼 생성자도 인스턴스 변수라고 할 수 있겠네요(self가 있으니까)
#         Bag.count += 1      # 생성자가 호출될 때 마다(=객체가 생성될 떄마다) 클래스 변수인 count가 1 씩 증가함. cls.count가 아니라 클래스명.count라는 것에 주목해야 합니다.
#         print('가방 객체가 생성되었습니다.')
#
#     # 클래스 메서드 정의
#     @classmethod
#     def sell(cls):
#         print('가방이 팔렸습니다.')
#         cls.count -= 1
#         # 얘는 클래스 메서드가 클래스 변수에 접근한 것이기 때문에 Bag.count가 아니라 cls.count로 작성되었습니다.
#
#     @classmethod
#     def remain_bag(cls):
#         return cls.count
#
# print(f'현재 가방 재고 : {Bag.count}')            # 결과값 : 현재 가방 재고 : 0
# print(f'현재 가방 재고 : {Bag.remain_bag()}')     # 결과값 : 현재 가방 재고 : 0
#
# # 객체 생성
# bag1 = Bag()                                    # 가방 객체가 생성되었습니다.
# print(f'현재 가방 재고 : {Bag.remain_bag()}')     # 결과값 : 현재 가방 재고 : 1
# bag2 = Bag()                                    # 가방 객체가 생성되었습니다.
# bag3 = Bag()                                    # 가방 객체가 생성되었습니다.
# print(f'현재 가방 재고 : {Bag.remain_bag()}')     # 결과값 : 현재 가방 재고 : 3
# bag1.sell()                                     # 가방이 팔렸습니다. → 실제로 bag1 객체가 사라진건 아닌거 아시죠?
# print(f'현재 가방 재고 : {Bag.remain_bag()}')     # 결과값 : 현재 가방 재고 : 2
# Bag.sell()                                      # 가방이 팔렸습니다.
# print(f'현재 가방 재고 : {Bag.remain_bag()}')     # 결과값 : 현재 가방 재고 : 1
'''
다음 지시사항을 읽고 이름과 전체 인구수를 저장할 수 있는 Person 클래스를 작성하시오.

지시 사항

1. 다음과 같은 방법으로 man과 woman 인스턴스를 생성하시오.
man = Person('김일')
woman = Person('김이')

2. man과 woman 인스턴스가 생성되면 다음과 같은 메시지를 출력 할 수 있도록 작성하시오.
김일이(가) 테어냈습니다.
김이이(가) 테어냈습니다.

3. 다음 코드를 통해서 전체 인구수를 조회할 수 있도록 작성하시오.
print(f'전체 인구수 : {Person.get_population()}')

4. 다음과 같은 명령어로 man 인스턴스를 삭제하시오.
del man

5. man 인스턴스가 삭제되면 다음과 같은 메시지를 출력할 수 있도록 소멸자를 정의하시오.
RIP 김일
'''
class Person:
    population = 0
    @classmethod
    def get_population(cls):
        return f'전체 인구수 : {cls.population}'

    def __init__(self, name):
        self.name = name
        print(f'{self.name}이(가) 태어났습니다.')
        Person.population += 1  # 인스턴스 메서드를 통해서 클래스 변수를 변화 시킨거니까 클래스명.클래스 변수명

    def __del__(self):
        print(f'RIP {self.name}')
        Person.population -= 1

print(Person.get_population()    # 전체 인구수 : 0
man = Person('김일')
woman = Person('김이')
print(Person.get_population())    # 전체 인구수 : 2
del man                            # RIP 김일 (소멸자)
print(Person.get_population())
print('프로그램 종료')
'''
▼ 결과값
전체인구수 : 0
김일이(가) 태어났습니다.
김이이(가) 태어났습니다.
전체인구수 : 2
RIP 김일
전체인구수 : 1
프로그램 종료
RIP 김이
'''
```
이상의 코드에서 주목할 점 : 
- 특정 메서드가 인스턴스 / 클래스 / 정적 메서드 중에 무엇이 되어야 하는가.
  - 클래스 변수가 있더라도 인스턴스 변수가 포함된다면 인스턴스 메서드로 작성하는 편.
    - 클래스 변수는 특정 인스턴스를 불러낼 수 가 없으니까요.
    - 반면에 인스턴스 메서드는 모든 인스턴스가 공유하는 클래스 변수를 클래스명.클래스변수명 으로 호출 할 수 있으니까요.

- 이상의 내용에서 생각해보자면 소멸자의 정의는 '객체의 소멸을 정의하는 메서드'이기 때문에 특정 객체에 가해지는 작용이라고 볼 수 있고, 또한 `RIP 김일`이라는 점에서 객체명.name 이라는 인스턴스 변수를 참조해야만 하기 때문에 population -= 1 을 쓰더라도 인스턴스 메서드로 정의하는 것이 적합해보입니다.